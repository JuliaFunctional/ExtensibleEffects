<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How it works · ExtensibleEffects.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaFunctional.github.io/ExtensibleEffects.jl/manual-how-it-works/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtensibleEffects.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual-introduction/">Introduction</a></li><li><a class="tocitem" href="../manual-effects/">Effects</a></li><li class="is-active"><a class="tocitem" href>How it works</a><ul class="internal"><li><a class="tocitem" href="#Key-ingredients"><span>Key ingredients</span></a></li><li><a class="tocitem" href="#Extensive-Example"><span>Extensive Example</span></a></li></ul></li><li><a class="tocitem" href="../manual-juliacon/">JuliaCon 2021</a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>How it works</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How it works</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFunctional/ExtensibleEffects.jl/blob/master/docs/src/manual-how-it-works.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-does-it-actually-work?"><a class="docs-heading-anchor" href="#How-does-it-actually-work?">How does it actually work?</a><a id="How-does-it-actually-work?-1"></a><a class="docs-heading-anchor-permalink" href="#How-does-it-actually-work?" title="Permalink"></a></h1><p><code>ExtensibleEffects</code> put everything into the meta monad <code>Eff</code> and somehow magically by doing so different monads can compose well together. Let&#39;s look a bit more into the details.</p><h2 id="Key-ingredients"><a class="docs-heading-anchor" href="#Key-ingredients">Key ingredients</a><a id="Key-ingredients-1"></a><a class="docs-heading-anchor-permalink" href="#Key-ingredients" title="Permalink"></a></h2><p>There are two main ingredience for this magic to work:</p><ol><li><code>Eff</code> is itself a Monad, hence you can work <em>within</em> <code>Eff</code> without caring about the precise workings of the computational context <code>Eff</code>.</li><li><code>Eff</code> is not only an arbitrary Monad, but a very generic one, sometimes called a kind of <em>free</em> Monad. The key result is that we can represent many many of our well known Monads into this <code>Eff</code> monad.</li><li>The ExtensibleEffects system guarantees that the <code>continuation</code> in <code>eff_flatmap(handler, continuation, effectful)</code> will always return an <code>Eff</code> with element type of the same type as <code>effectful</code> itself. This makes it possible to define your own effect-handlers <em>independent</em> of all the other effect-handlers.</li></ol><p>The monad implementation is very simple indeed.</p><pre><code class="language-julia hljs">TypeClasses.pure(::Type{&lt;:Eff}, a) = noeffect(a)
TypeClasses.map(f, eff::Eff) = TypeClasses.flatmap(noeffect ∘ f, eff)
TypeClasses.flatmap(f, eff::Eff) = Eff(eff.effectful, Continuation(eff.cont.functions..., f))</code></pre><p>In brief, it just stores all functions for later execution in the <code>Continuation</code> attribute <code>cont</code>. The first function in the <code>Continuation</code> is later applied directly to the <code>eff.effectful</code>, the second function in <code>cont</code> is applied to the result of the first function, the third to the result of that, and so forth (with the addition that all functions return <code>Eff</code> which wrap the results). That is it.</p><hr/><p>Let&#39;s look at the third ingredient, why the continuation always returns an <code>Eff</code> of the very same type.</p><p>What is actually the element type of an <code>Eff</code>? It is not the typeparameter <code>Eff{ElementType}</code>, because <code>Eff</code> is defined as <code>Eff{Effectful, Continuation}</code>. We can nevertheless get an intuitive feeling for the element type: When using <code>map</code>/<code>flatmap</code> like in</p><pre><code class="language-julia hljs">flatmap(eff) do value
  # ...
end</code></pre><p>The element is the argument to our anonymous function which we map over the container. For example above, the element type would be <code>typeof(value)</code>.</p><p>For <code>Eff</code> the <code>value</code> of <code>flatmap</code> is specified by whatever function is mapped right befor our call to map. To understand what this is, we need to take a look into whatever is calling our <code>eff_flatmap</code>. It turns out this is <code>ExtensibleEffects.runhandler</code>. Here is its definition:</p><pre><code class="language-julia hljs">function runhandler(handler, eff::Eff)
  eff_applies(handler, eff.effectful) || return runhandler_not_applies(handler, eff)

  interpreted_continuation = if isempty(eff.cont)
    # `_eff_pure` just calls `eff_pure` and ensures that the return value is of type `Eff`
    Continuation(x -&gt; _eff_pure(handler, x))
  else
    Continuation(x -&gt; runhandler(handler, eff.cont(x)))
  end
  # `_eff_flatmap` just calls `eff_flatmap` and ensures that the return value is of type `Eff`
  _eff_flatmap(handler, interpreted_continuation, eff.effectful)
end</code></pre><p>It is quite similar to our custom handler we wrote for <code>State</code>. In the first line we again check whether our current handler actually applies. For our purposes at the moment, we are only interested in the case where it applies, so we can go on to line 3: Here we construct the actual continuation which is then passed to <code>eff_flatmap</code>. The last line then is already our call to <code>eff_flatmap</code> which we wanted to understand in more detail.</p><p>Let&#39;s summarize the situation and the goal again. It is simpler to follow if we take concrete example. Let&#39;s consider that <code>eff.effectful</code> is of type <code>Vector</code>, and that also <code>handler = Vector</code>. We want to understand why the continuation, here <code>interpreted_continuation</code>, is returning an <code>Eff</code> with element type <code>Vector</code> as well.</p><p>Looking at the definition of <code>interpreted_continuation</code> we can directly read out its return value.</p><ol><li><p>In the first case, if <code>isempty(eff.cont)</code>, we get an <code>_eff_pure(Vector, ...)</code> which indeed will construct an <code>Eff</code> with element type <code>Vector</code> (the continuation of that <code>Eff</code> is still empty).</p></li><li><p>In the second case we get <code>runhandler(Vector, eff.cont(x))</code>, which recurses into our very function <code>runhandler</code> itself. What does it return?</p><ol><li><p>If the <code>Vector</code> handler applies to the next effect <code>eff.cont(x)::Eff</code>, we return <code>eff_flatmap(...)</code>. Remember <code>eff_flatmap</code> belongs to the core interface and indeed for <code>Vector</code> always return an <code>Eff</code> of element type <code>Vector</code>, if everything goes right.</p></li><li><p>If the <code>Vector</code> handler does not apply to the next effect <code>eff.cont(x)</code>, we return <code>runhandler_not_applies(Vector, eff)</code>. Here is its definition</p><pre><code class="language-julia hljs">function runhandler_not_applies(handler, eff::Eff)
  interpreted_continuation = if isempty(eff.cont)
    Continuation(x -&gt; _eff_pure(handler, x))
  else
    Continuation(x -&gt; runhandler(handler, eff.cont(x)))
  end
  Eff(eff.effectful, interpreted_continuation)
end</code></pre><p>The <code>interpreted_continuation</code> is constructed exactly identically. The only difference is that instead of calling <code>eff_flatmap</code>, we construct an <code>Eff</code> which will remember to run our handler for subsequent effects. We are interested in the element type of this returned <code>Eff</code>, which is directly defined by what <code>interpreted_continuation</code> returns, same as before.</p><ol><li>In the first case we have <code>_eff_pure(Vector, ...)</code> again, which is an Eff of element type Vector.</li><li>In the second case we recurse one more time into our well known <code>runhandler(Vector, ...)</code>, what does it return? At this point we already have been once. We have seen all branches our function can take: There was the <code>_eff_pure(Vector, ...)</code> branch, which is returning an <code>Eff</code> of element type <code>Vector</code> quite trivially. There was <code>_eff_flatmap</code> which does so as well by definition. Finally there is the recursion branch. Assuming now that the recursion ends, it will itself end in branch one or two and hence also return an <code>Eff</code> of element type <code>Vector</code>.</li></ol></li></ol></li></ol><p>To emphasize one implicit but very important aspect of the above argument: Whether things are actually computed or just stored for later execution, to understand which element type the <code>Eff</code> has it is not decisive. Everything which matters is what is going to be executed right before. This way the different handlers can actually stack their computations on top of each other without interferring.</p><h2 id="Extensive-Example"><a class="docs-heading-anchor" href="#Extensive-Example">Extensive Example</a><a id="Extensive-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Extensive-Example" title="Permalink"></a></h2><p>Finally let&#39;s look at a concrete example of running two simple handlers, <code>Vector</code> and <code>Writer</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @syntax_eff begin
         a = [2, 3]
         b = Writer(&quot;hello.&quot;, a*a)
         c = [7, 8]
         d = Writer(&quot;world.&quot;, a+b+c)
         @pure a, b, c, d
       end
4-element Vector{Writer{String, NTuple{4, Int64}}}:
 Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13))
 Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 8, 14))
 Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (3, 9, 7, 19))
 Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (3, 9, 8, 20))

julia&gt; eff = @syntax_eff_noautorun begin
         a = [2, 3]
         b = Writer(&quot;hello.&quot;, a*a)
         c = [7, 8]
         d = Writer(&quot;world.&quot;, a+b+c)
         @pure a, b, c, d
       end
Eff(effectful=[2, 3], length(cont)=1)</code></pre><p><code>@syntax_eff</code> uses autorun and hence is just the same as manually running <code>@runhandlers (Vector, Writer) @syntax_eff_noautorun ...</code>, which again translates into</p><pre><code class="language-julia hljs">import ExtensibleEffects: runhandler, runlast_ifpossible, Continuation
runlast_ifpossible(runhandler(Vector, runhandler(Writer, eff)))</code></pre><p>where <code>eff</code> refers to the above variable storing the result of <code>@syntax_eff_noautorun</code>. Let&#39;s go step by step:</p><ul><li><p>we start with <code>runhandler(Writer, eff)</code></p></li><li><p>the first effect found is not of type Writer, and the <code>Eff</code> has still a continuation left, i.e. <code>eff.cont</code> is not empty. Hence we construct <code>Eff(eff.effectful, interpreted_continuation_Writer1)</code> where <code>interpreted_continuation_Writer1</code> recurses into <code>runhandler</code> using the handler <code>Writer</code>. The inner <code>eff.cont</code> is the very first continuation, capturing the entire computation.</p><pre><code class="language-julia hljs">original_continuation1(a) = @syntax_eff_noautorun begin
  b = Writer(&quot;hello.&quot;, a*a)
  c = [7, 8]
  d = Writer(&quot;world.&quot;, a+b+c)
  @pure a, b, c, d
end

interpreted_continuation_Writer1(a) = runhandler(Writer, original_continuation1(a))</code></pre></li><li><p><code>eff2 = runhandler(Writer, eff)</code> already returns</p></li><li><p><code>runhandler(Vector, eff2)</code> is run</p></li><li><p>the first effect found is of type Vector, and the <code>eff2.cont</code> is again non-empty - it is just our <code>interpreted_continuation_Writer1</code>. Hence we will construct a new continuation, let&#39;s call it <code>interpreted_continuation_Vector1</code>, which recurses into <code>runhandler</code> using the handler <code>Vector</code>. We can specify it more concretely as</p><pre><code class="language-julia hljs">interpreted_continuation_Vector1 = Continuation(x -&gt; runhandler(Vector, interpreted_continuation_Writer1(x)))</code></pre></li><li><p>this <code>interpreted_continuation_Vector1</code> is now passed to <code>eff_flatmap</code> for Vector which will call this continuation for all values, here <code>2</code> and <code>3</code>.</p></li><li><p><code>interpreted_continuation_Vector1(2)</code> returns the results of this first branch, which is now a pure value (which you can see at <code>length(cont)=0</code>)</p><pre><code class="language-julia hljs">julia&gt; interpreted_continuation_Vector1(2)
Eff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 4, 10)), Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 5, 11))]), length(cont)=0)</code></pre><ul><li><p>Let&#39;s look into <code>interpreted_continuation_Writer1(2)</code></p><pre><code class="language-julia hljs">julia&gt; eff3 = interpreted_continuation_Writer1(2)
Eff(effectful=[4, 5], length(cont)=2)</code></pre><ul><li><p>Given <code>a = 2</code>, the original program could continue and returned an <code>Eff</code> with the first <code>Writer</code> as its effectful value and all the rest as the continuation.</p><pre><code class="language-julia hljs">function original_continuation2(b)
  a = 2
  @syntax_eff_noautorun begin
    c = [7, 8]
    d = Writer(&quot;world.&quot;, a+b+c)
    @pure a, b, c, d
  end
end</code></pre></li><li><p>Then <code>runhandler(Writer, ...)</code> was called on top if it, finding an effectful <code>Writer</code> and non-empty continuation <code>original_continuation2</code> and hence constructing a new continuation</p><pre><code class="language-julia hljs">interpreted_continuation_Writer2 = Continuation(x -&gt; runhandler(Writer, original_continuation2(x)))</code></pre><p>which is then passed to <code>eff_flatmap</code>.</p></li><li><p>Within <code>eff_flatmap</code>, the <code>Writer</code>&#39;s inner value is extracted, a <code>4 = 2*2</code>, and passed on to the continuation.</p><pre><code class="language-julia hljs">julia&gt; interpreted_continuation_Writer2(4)
Eff(effectful=[7, 8], length(cont)=1)</code></pre><p>Here what happened step by step:</p><ul><li><p><code>eff4 = original_continuation2(4)</code> was called, returning the next program step <code>Eff(effectful=[4, 5], length(cont)=1)</code></p></li><li><p><code>runhandler(Writer, eff4)</code> found a Vector which it cannot handle, and in addition the Effect has a non-empty continuation. Hence it returns an <code>Eff</code> with the same effectful (the Vector here) and applying <code>runhandler(Writer, ...)</code> to the continuation.</p><pre><code class="language-julia hljs">function original_continuation3(c)
  a = 2
  b = 4
  @syntax_eff_noautorun begin
    d = Writer(&quot;world.&quot;, a+b+c)
    @pure a, b, c, d
  end
end

interpreted_continuation_Writer3 = Continuation(x -&gt; runhandler(Writer, original_continuation3(x)))</code></pre><p>That is also why the length of <code>eff.cont</code> hasn&#39;t changed. <code>original_continuation3</code> was simply replaced with <code>interpreted_continuation_Writer3</code>.</p></li></ul></li><li><p>finally <code>eff_flatmap</code> for <code>Writer</code> will work within the returned <code>Eff</code> using <code>Eff</code>&#39; monad-power, and combine its accumulator to the accumulator of the going-to-be Writer within the <code>Eff</code>.</p><pre><code class="language-julia hljs">function ExtensibleEffects.eff_flatmap(continuation, a::Writer)
  eff_of_writer = continuation(a.value)
  map(eff_of_writer) do b
    Writer(a.acc ⊕ b.acc, b.value)
  end
end</code></pre><p>As <code>Eff</code> does not actually compute anything, but just stores the computation for later execution by appending it to <code>eff.cont</code>, we arrive at our final result</p><pre><code class="language-julia hljs">julia&gt; eff3 = interpreted_continuation_Writer1(2)
Eff(effectful=[7, 8], length(cont)=2)</code></pre></li></ul></li><li><p><code>runhandlers(Vector, eff3)</code></p><ul><li><p>it will find an effectful of the correct type and a non-empty continuation, hence creating a continuation</p><pre><code class="language-julia hljs">interpreted_continuation_Vector2(x) = runhandler(Vector, eff3.cont(x))</code></pre><p>and passing it to <code>eff_flatmap</code></p></li><li><p><code>eff_flatmap</code> will now run it for both of its values <code>7</code> and <code>8</code>, starting with <code>7</code></p></li><li><p><code>eff3.cont(7)</code> gives a pure result (<code>length(cont)=0</code>) of type <code>NoEffect{Writer}</code>. Note that this is not a <code>Writer</code> effect, but really the end-result which gets wrapped into the trivial effect <code>NoEffect</code>.</p><pre><code class="language-julia hljs">julia&gt; eff3.cont(7)
Eff(effectful=NoEffect{Writer{String, NTuple{4, Int64}}}(Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13))), length(cont)=0)</code></pre><p>How does this came about?</p><ul><li><p><code>eff3.cont</code> contains two continuations, the first was <code>interpreted_continuation_Writer3</code> (<code>original_continuation3</code> followed by <code>runhandler(Writer, ...)</code>) and the second came from the extra <code>map</code> operation from within <code>Writer</code>&#39;s <code>eff_flatmap</code> operation.</p></li><li><p><code>eff5 = original_continuation3(7)</code> just continues our original program</p><pre><code class="language-julia hljs">julia&gt; original_continuation3(7)
Eff(effectful=Writer{String, Int64}(&quot;world.&quot;, 13), length(cont)=1)</code></pre><p>The continuation in here is just the last part of our program</p><pre><code class="language-julia hljs">function original_continuation4(d)
  a = 2
  b = 4
  c = 7
  # the following is invalid syntax, because julia cannot typeinfer the effect type which would be needed to call `pure`
  # @syntax_eff_noautorun begin
  #   @pure a, b, c, d
  # end

  # instead we can construct pure manually
  noeffect((a, b, c, d))
end</code></pre></li><li><p><code>interpreted_continuation_Writer3(7)</code> is just <code>runhandler(Writer, eff5)</code>. The <code>Writer</code> handler finds a matching effectful and non-empty continuation, hence creating a new continuation</p><pre><code class="language-julia hljs">interpreted_continuation_Writer4(x) = runhandler(Writer, original_continuation4(x))</code></pre><p>which is then passed into Writer&#39;s <code>eff_flatmap</code></p><ul><li><p><code>eff_flatmap</code> extracts the value from the current <code>Writer</code>, which is <code>13</code> here, and passes it to the continuation</p></li><li><p>The original continuation returns a <code>NoEffect</code> effect type which contains the final <code>Tuple</code></p><pre><code class="language-julia hljs">julia&gt; eff6 = original_continuation4(13)
Eff(effectful=NoEffect{NTuple{4, Int64}}((2, 4, 7, 13)), length(cont)=0)</code></pre></li><li><p>Calling <code>runhandler(Writer, eff6)</code> on it will find non matching effect and empty continuation. Hence it constructs a new <code>Eff</code> with original value and new continuation <code>x -&gt; eff_pure(Writer, x)</code>.</p><pre><code class="language-julia hljs">julia&gt; runhandler(Writer, eff6)
Eff(effectful=NoEffect{Writer{typeof(TypeClasses.neutral), NTuple{4, Int64}}}(Writer{typeof(TypeClasses.neutral), NTuple{4, Int64}}(TypeClasses.neutral, (2, 4, 7, 13))), length(cont)=0)</code></pre></li><li><p>For performance reasons the <code>Eff</code> constructor will directly execute any computation which is run on an <code>NoEffect</code> effect. This explains the new effectful and <code>length(cont)=0</code>. You also see that mapping over <code>NoEffect</code> will actually get the wrapped value (here a <code>Tuple</code>) as the input, which is then wrapped into <code>Writer</code>.</p></li><li><p><code>eff_flatmap</code> will then merge the accumulators, namely the <code>&quot;world.&quot;</code> from the plain <code>Writer</code> as well as the pure accumulator <code>TypeClasses.neutral</code> introduced by <code>eff_pure</code>. The merging is again realized by mapping over the <code>Eff</code>, and as we reached <code>NoEffect</code> effect, all computations are now directly executed.</p></li></ul></li><li><p>at last the old <code>eff_flatmap</code> operation gets active, which now merges the accumulators of the inner Writer <code>&quot;world.&quot;</code> and the outer accumulator <code>&quot;hello.&quot;</code>. The merging is again realized by mapping over the <code>Eff</code>, and as the effect is already <code>NoEffect</code>, the computation is executed immediately, giving us</p><pre><code class="language-julia hljs">julia&gt; eff3.cont(7)
Eff(effectful=NoEffect{Writer{String, NTuple{4, Int64}}}(Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13))), length(cont)=0)</code></pre></li></ul></li><li><p><code>runhandler(Vector, eff3.cont(7))</code> finds now an <code>Eff</code> with empty continuation and different type <code>Writer</code>, hence a new <code>Eff</code> is build with <code>eff_pure</code></p><pre><code class="language-julia hljs">Eff(eff3.effectful, Continuation(x -&gt; _eff_pure(Vector, x)))</code></pre><p>For performance improvements, the computation on <code>NoEffect</code> is again directly executed, leading into a new <code>NoEffect</code> of <code>Vector</code> of <code>Writer</code>.</p><pre><code class="language-julia hljs">julia&gt; runhandler(Vector, eff3.cont(7))
Eff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13))]), length(cont)=0)</code></pre></li><li><p>The same happens for value <code>8</code>, returning another <code>Eff</code> of <code>NoEffect</code> of <code>Vector</code> of <code>Writer</code></p></li><li><p>Using the monad power of <code>Eff</code>, both results are now combined by flattening them</p><pre><code class="language-julia hljs">julia&gt; @syntax_flatmap begin
        a = interpreted_continuation_Vector2(7)
        b = interpreted_continuation_Vector2(8)
        @pure [a...; b...]
      end
Eff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13)), Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 8, 14))]), length(cont)=0)</code></pre><p>The concrete implementation of <code>Vector</code>&#39;s <code>eff_flatmap</code> is slightly more general, but the principle is the same.</p></li></ul></li></ul></li><li><p>the continuation for the outer Vector (<code>interpreted_continuation_Vector1</code>) is now executed for the second value <code>3</code>, too,  giving another <code>NoEffect</code> plain value.</p></li><li><p>analogously to how the inner two computations have been merged, also the outer two <code>Eff</code> of <code>NoEffect</code> of <code>Vector</code> get merged. We almost have our end result.</p><pre><code class="language-julia hljs">julia&gt; runhandler(Vector, runhandler(Writer, eff))
Eff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13)), Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 8, 14)), Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (3, 9, 7, 19)), Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (3, 9, 8, 20))]), length(cont)=0)</code></pre></li><li><p>Finally <code>runlast_ifpossible</code> tries to extract the value out of the <code>Eff</code>-<code>NoEffect</code> combination.</p><pre><code class="language-julia hljs">julia&gt; runlast_ifpossible(runhandler(Vector, runhandler(Writer, eff)))
4-element Vector{Writer{String, NTuple{4, Int64}}}:
Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 7, 13))
Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (2, 4, 8, 14))
Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (3, 9, 7, 19))
Writer{String, NTuple{4, Int64}}(&quot;hello.world.&quot;, (3, 9, 8, 20))</code></pre></li></ul><p>We have seen the concrete execution of one example, including how the effect system separates lazy computation from actual computation. As long as we haven&#39;t reached <code>NoEffect</code> and still have unkown handlers to handle, all computation is just lazily stored as functions for later execution. As soon as all handlers are handled, the result is wrapped into the special <code>NoEffect</code> effect, on which computation is now executed immediately. From the perspective of the user, the precise timing when something is executed is just an implementation. Hence also <code>NoEffect</code> is an implementation detail and you never need to worry about it. Still I hope this helped the interested reader to understand in more detail what is going on behind the scenes.</p><hr/><p>That is it, I hope it is a little bit less magical now, however I myself have to commit that even after implementing the whole package, the power of the extensible effects concept keeps blowing my mind and stays magic.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual-effects/">« Effects</a><a class="docs-footer-nextpage" href="../manual-juliacon/">JuliaCon 2021 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 27 July 2021 17:39">Tuesday 27 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
