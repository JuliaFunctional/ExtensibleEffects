var documenterSearchIndex = {"docs":
[{"location":"library/#ExtensibleEffects-Public-API","page":"Library","title":"ExtensibleEffects Public API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = ExtensibleEffects","category":"page"},{"location":"library/#Usage-and-Syntax","page":"Library","title":"Usage and Syntax","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Autorun","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@syntax_eff\n@syntax_eff_noautorun\nnoautorun","category":"page"},{"location":"library/#ExtensibleEffects.@syntax_eff","page":"Library","title":"ExtensibleEffects.@syntax_eff","text":"@syntax_eff begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nExtensible Effects syntax. It applies effect to all values which are not prefaced with @pure, which lifts them into the Eff monad.  The results are combined using @syntax_flatmap on the respective Eff monad, which finally is executed using autorun algorithm.\n\nExamples\n\nautohandled_eff = @syntax_eff begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nmycustomwrapper(i::Int) = collect(1:i)\n# monadic-like syntax to first apply a wrapper before interpreting code to unhandled effects\nautohandled_eff = @syntax_eff mycustomwrapper begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nThe Interface\n\nIf you want to add support for new types, you need to provide the following interface: (Vector is only an example)\n\ncore function description\nExtensibleEffects.eff_applies(handler::Type{<:Vector}, effectful::Vector) = true specify on which values the handler applies (the handler Vector applies to Vector of course)\nExtensibleEffects.eff_pure(handler::Type{<:Vector}, value) = [value] wrap a plain value into the Monad of the handler, here Vector.\nExtensibleEffects.eff_flatmap(continuation, effectful::Vector) apply a continuation to the current effect (here again Vector as an example). The key difference to plain TypeClasses.flatmap is that continuation does not return a plain Vector, but a Eff{Vector}. Applying this continuation with a plain map would lead Vector{Eff{Vector}}. However, eff_flatmap needs to return an Eff{Vector} instead.\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.@syntax_eff_noautorun","page":"Library","title":"ExtensibleEffects.@syntax_eff_noautorun","text":"@syntax_eff_noautorun begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nExtensible Effects syntax which does not run autorun routine. As @syntax_eff, it applies effect to all values which are not prefaced with @pure,  which lifts them into the Eff monad. The results are combined using @syntax_flatmap on the respective Eff monad, which then is directly returned.\n\nExamples\n\nunhandled_eff = @syntax_eff_noautorun begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nmycustomwrapper(i::Int) = collect(1:i)\n# monadic-like syntax to first apply a wrapper before interpreting code to unhandled effects\nunhandled_eff = @syntax_eff_noautorun mycustomwrapper begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.noautorun","page":"Library","title":"ExtensibleEffects.noautorun","text":"noautorun(handlers...)::Function\n\nConstructs a wrapper function which can be used within @syntax_eff to skip all given handler types within the autorun.\n\nExample\n\n@syntax_eff noautorun(Vector, Identity) begin\n  a = [1,2,3]\n  b = Identity(a + 2)\nend\n\nwill actually run no handler at all in the implicit autorun, as both handlers are marked for ignore.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Explicit introduction of effects","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"effect\nnoeffect","category":"page"},{"location":"library/#ExtensibleEffects.effect","page":"Library","title":"ExtensibleEffects.effect","text":"mark a value as an effect\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.noeffect","page":"Library","title":"ExtensibleEffects.noeffect","text":"mark a value as no effect, but plain value\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Explicit use of handlers","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"runhandlers\n@runhandlers","category":"page"},{"location":"library/#ExtensibleEffects.runhandlers","page":"Library","title":"ExtensibleEffects.runhandlers","text":"runhandlers(handlers, eff)\nrunhandlers((Vector, Option), eff)::Vector{Option{...}}\n\nrun all handlers such that the first handler will define the most outer container\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.@runhandlers","page":"Library","title":"ExtensibleEffects.@runhandlers","text":"@runhandlers handlers eff\n\nFor convenience we provide runhandlers function also as a macro.\n\nWith this you can easier run left-over handlers from an @syntax_eff autorun.\n\nExample\n\n@runhandlers WithCall(args, kwargs) @syntax_eff begin\n  a = Callable(x -> 2x)\n  @pure a\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#Interface","page":"Library","title":"Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Core Interface","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"eff_applies\neff_pure\neff_flatmap","category":"page"},{"location":"library/#ExtensibleEffects.eff_applies","page":"Library","title":"ExtensibleEffects.eff_applies","text":"ExtensibleEffects.eff_applies(handler::YourHandlerType, value::ToBeHandledEffectType) = true\n\nOverwrite this function like above to indicate that a concrete effect is handled by a handler. In most cases you will have YourHandlerType = Type{ToBeHandledEffectType}, like for Vector or similar.\n\nSometimes you need extra information without which you cannot run a specific effect. Then you need to link the specific handler containing the required information. E.g. Callable needs args and kwargs to be run, which are captured in the handler type CallableHandler(args, kwargs). Hence above you would choose YourHandlerType = CallableHandler, and ToBeHandledEffectType = Callable.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.eff_pure","page":"Library","title":"ExtensibleEffects.eff_pure","text":"ExtensibleEffects.eff_pure(handler, value)\n\nOverwrite this for your custom effect handler, return either ExtensibleEffects.Eff type, or a plain value. Plain values will be wrapped with noeffect automatically.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.eff_flatmap","page":"Library","title":"ExtensibleEffects.eff_flatmap","text":"ExtensibleEffects.eff_flatmap(handler, interpreted_continuation, value)\nExtensibleEffects.eff_flatmap(interpreted_continuation, value)\n\nOverwrite this for your custom effect handler to handle your effect. This function is only called if eff_applies(handler, value)==true.\n\nWhile for custom effects it is handy to dispatch on the handler itself, in simple cases handler == typeof(value) and hence, we allow to ommit it.\n\nParameters\n\nThe arg interpreted_continuation is guaranteed to return an Eff of the handled type. E.g. if you might handle the type Vector, you are guaranteed that interpreted_continuation(x)::ExtensibleEffects.Eff{Vector}\n\nReturn\n\nIf you do not return an ExtensibleEffects.Eff, the result will be wrapped into noeffect automatically, i.e. assuming the effect is handled afterwards.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"optional extra for autorun (in 99% not needed)","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"eff_autohandler","category":"page"},{"location":"library/#ExtensibleEffects.eff_autohandler","page":"Library","title":"ExtensibleEffects.eff_autohandler","text":"eff_autohandler(value) = Base.typename(typeof(value)).wrapper\n\nOverwrite this if the default autohandler extraction does not work for your case. E.g. for value::Vector the default would return Array, hence we need to overwrite it individually.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"for developing advanced effects like State","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"runhandler\nrunhandler_not_applies","category":"page"},{"location":"library/#ExtensibleEffects.runhandler","page":"Library","title":"ExtensibleEffects.runhandler","text":"runhandler(handler, eff::Eff)\nrunhandler(handler, eff::Eff, context)\n\nkey method to run an effect on some effecthandler Eff\n\nnote that we represent effectrunners as plain types in order to associate standard effect runners with types like Vector, Option, ...\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.runhandler_not_applies","page":"Library","title":"ExtensibleEffects.runhandler_not_applies","text":"runhandler_not_applies(handler, eff)\n\nif your handler does not apply, use this as the fallback to handle the unknown effect. \n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"for developing composable effect-handler-macros","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@insert_into_runhandlers","category":"page"},{"location":"library/#ExtensibleEffects.@insert_into_runhandlers","page":"Library","title":"ExtensibleEffects.@insert_into_runhandlers","text":"@insert_into_runhandlers outer_handler @syntax_eff begin\n  # ...\nend\n\nNext to simple Effects which can be directly composed down to plain values and reconstructed again from plain values, there are also a couple of more elaborate Effects, which values cannot be extracted without providing further context.\n\nCallables are a good example. It is impossible to extract the values of a callable without calling it, or without constructing another Callable around it.\n\nWith all these example the typical flow would be like\n\n\nCallable(function (args...; kwargs...)\n  callablehandler = CallableHandler(args...; kwargs...)\n\n  SomeOtherNeededContext() do info\n    otherhandler = SomeOtherHandler(info)\n\n    # ... possibly further nestings\n\n    @runhandlers (callablehandler, otherhandler #= possible further handlers =#) @syntax_eff begin\n      # ...\n    end\n  end\nend)\n\n@inser_into_runhandlers can be used to simplify and even separate these outer handlers from one another, so that they can be used as composable interchangeable macros.\n\nFor example, here the implementation of @runcallable (ignoring macro hygiene)\n\nmacro runcallable(expr)\n  :(Callable(function(args...; kwargs...)\n    @insert_into_runhandlers(CallableHandler(args...; kwargs...), $expr)\n  end))\nend\n\nThis will search for an existing call to runhandlers within the given expr, and if found, inserts the CallableHandler similar to the motivating example above. If no runhandlers is found, it will create a new one.\n\nThis way, you can compose the nested code-structures very easily. You only have to be careful, that you always run all outer effects at once, in one single statement, so that @insert_into_runhandlers can actually find the right runhandlers.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Effect-Handlers","page":"Library","title":"Effect Handlers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Writer","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"WriterHandler","category":"page"},{"location":"library/#ExtensibleEffects.WriterHandler","page":"Library","title":"ExtensibleEffects.WriterHandler","text":"WriteHandler(pure_accumulator=neutral)\n\nHandler for generic Writers. The default accumulator works with Option values.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Callable","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"CallableHandler\n@runcallable","category":"page"},{"location":"library/#ExtensibleEffects.CallableHandler","page":"Library","title":"ExtensibleEffects.CallableHandler","text":"CallableHandler(args...; kwargs...)\n\nHandler for functions, providing the arguments and keyword arguments for calling the functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.@runcallable","page":"Library","title":"ExtensibleEffects.@runcallable","text":"@runcallable(eff)\n\ntranslates to\n\nCallable(function(args...; kwargs...)\n  @insert_into_runhandlers CallableHandler(args...; kwargs...) eff\nend)\n\nThanks to @insert_into_runhandlers this outer runner can compose well with other outer runners.\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"State","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"StateHandler\n@runstate","category":"page"},{"location":"library/#ExtensibleEffects.StateHandler","page":"Library","title":"ExtensibleEffects.StateHandler","text":"StateHandler(state)\n\nHandler for running State. Gives the initial state.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.@runstate","page":"Library","title":"ExtensibleEffects.@runstate","text":"@runstate eff\n\nNote that unlike Callable, a State has to ensure that it is always the first outer Eff being run, as it returns the inner state as an additional argument.\n\nIf you would nest it with runcallable, e.g. like @runstate @runcallable eff it wouldn't work, as now the appended state is within the Callable and not directly within the State.\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"ContextManager","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ContextManagerHandler\n@runcontextmanager\n@runcontextmanager_\nContextManagerCombinedHandler","category":"page"},{"location":"library/#ExtensibleEffects.ContextManagerHandler","page":"Library","title":"ExtensibleEffects.ContextManagerHandler","text":"ContextManagerHandler(continuation)\n\nHandler for DataTypesBasic.ContextManager.\n\nThe naive handler implementation for contextmanager would immediately run the continuation within the contextmanager. However this does not work, as handling one effect does not mean that all \"inner\" effects are already handled. Hence, such a handler would actually initialize and finalize the contextmanager, without its value being processed already. When the other \"inner\" effects are run later on, they would find an already destroyed contextmanager session. We need to make sure, that the contextmanager is really the last Effect run. Therefore we create a custom handler.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.@runcontextmanager","page":"Library","title":"ExtensibleEffects.@runcontextmanager","text":"@runcontextmanager(eff)\n\ntranslates to\n\nContextManager(function(cont)\n  @insert_into_runhandlers ContextManagerHandler(cont) eff\nend)\n\nThanks to @insert_into_runhandlers this outer runner can compose well with other outer runners.\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.@runcontextmanager_","page":"Library","title":"ExtensibleEffects.@runcontextmanager_","text":"@runcontextmanager_(eff)\n\nlike @runcontextmanager(eff), but immediately runs the final ContextManager\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.ContextManagerCombinedHandler","page":"Library","title":"ExtensibleEffects.ContextManagerCombinedHandler","text":"ContextManagerCombinedHandler(otherhandler)\n\nWe can combine ContextManager with any other Handler. This is possible because ContextManager, within eff_flatmap, does not constrain the returned eff of the continuation.\n\n\n\n\n\n","category":"type"},{"location":"library/#Internals","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Core DataTypes","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Eff\nContinuation\nNoEffect","category":"page"},{"location":"library/#ExtensibleEffects.Eff","page":"Library","title":"ExtensibleEffects.Eff","text":"central data structure which can capture Effects in a way that they can interact, while each is handled independently on its own\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.Continuation","page":"Library","title":"ExtensibleEffects.Continuation","text":"only for internal purposes, captures the still unevaluated part of an Eff\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.NoEffect","page":"Library","title":"ExtensibleEffects.NoEffect","text":"special Wrapper, which is completely peeled of again\n\nComparing to Identity, Identity{T} results in Identity{T}, while NoEffect{T} results in plain T.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"autorun","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"autorun\nNoAutoRun","category":"page"},{"location":"library/#ExtensibleEffects.autorun","page":"Library","title":"ExtensibleEffects.autorun","text":"autorun(eff)\n\nspecial effectrunner which recognizes effecttypes used within eff and calls the effects in order, such that the first effect found will at the end be the most outer container, and the last different effect found will be the most inner container of the result value.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.NoAutoRun","page":"Library","title":"ExtensibleEffects.NoAutoRun","text":"Wrapper to indicate that a given handler should not be handled within autorun\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"other","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"runhandler\nrunlast\nrunlast_ifpossible","category":"page"},{"location":"library/#ExtensibleEffects.runlast","page":"Library","title":"ExtensibleEffects.runlast","text":"runlast(eff::Eff)\n\nextract final value from Eff with all effects (but Identity) already run\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.runlast_ifpossible","page":"Library","title":"ExtensibleEffects.runlast_ifpossible","text":"runlast_ifpossible(eff::Eff)\n\nlike ExtensibleEffects.runlast, however if the Eff is not yet completely handled, it just returns it.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Welcome to ExtensibleEffects.jl. This package provides an implementation of Extensible Effects. One concrete approach was presented in the paper Freer Monads, More Extensible Effects which already has an Haskell implementation as well as a Scala implementation.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This Julia implementation is massively simplified, and hence can also serve as a good introduction to get to know the details behind Extensible Effects.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many effects are provided, ranging from Option, which can be handled very simple, to the very limit of what can be supported by ExtensibleEffects - the State effect. Still, all the implementations are short and easy to follow, so look into the instances.jl file to see how to write your own Effect handlings.","category":"page"},{"location":"manual/#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Pkg\nPkg.add(\"ExtensibleEffects\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Use it like","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using ExtensibleEffects","category":"page"},{"location":"manual/#eff_applies,-eff_pure,-eff_flatmap","page":"Manual","title":"eff_applies, eff_pure, eff_flatmap","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Option, Vector, Iterable and many more are handled by overwriting the three core functions. We specify them by using Vector as an example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"core function description\neff_applies(handler::Type{<:Vector}, effectful::Vector) = true specify on which values the handler applies (the handler Vector applies to Vector of course)\neff_pure(handler::Type{<:Vector}, value) = [value] wrap a plain value into the Monad of the handler, here Vector.\neff_flatmap(continuation, effectful::Vector) apply a continuation to the current effect (here again Vector as an example). The key difference to plain TypeClasses.flatmap is that continuation does not return a plain Vector, but a Eff{Vector}. Applying this continuation with a plain map would lead Vector{Eff{Vector}}. However, eff_flatmap needs to return an Eff{Vector} instead.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO show at least the implementation of one example, say Option.","category":"page"},{"location":"manual/#More-Complex-ExtensibleEffect-Handlers","page":"Manual","title":"More Complex ExtensibleEffect Handlers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"While Option, Try, ContextManager, and the like, have almost trivial implementations, Vector, Iterable, and Writer need a bit more interaction with the effect system.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO add implementation example","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All these can still be run automatically, without any further context parameters. In ExtensibleEffect terms, this means that Option, Vector, Iterable and the like are handlers by its own. We acknowledge this everytime we define eff_applies like such ExtensibleEffects.eff_applies(handler::Type{<:HandlerType}, value::HandlerType) = true.","category":"page"},{"location":"manual/#Handlers-With-Additional-Parameters","page":"Manual","title":"Handlers With Additional Parameters","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO Writer example","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The background story, why we need this and cannot directly work on Callable itself, is that within the ExtensibleEffects framework, effects always need to be transform to noeffect, which is just the Identity Monad effect. This means we have to able to work on plain values, and cannot work on opaque Functors. See the Limitations section for further details on this.","category":"page"},{"location":"manual/#Handlers-which-need-to-be-updated-from-one-effect-to-another","page":"Manual","title":"Handlers which need to be updated from one effect to another","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO State example  (without outer handling) The most advanced possibility to define effects is showcased by State. It needs a custom handler which provides the initial state information StateHandler(state), similar to Callable. In addition, every effect actually adapts the state, and hence the handler itself must be updated accordingly so that subsequent effects are actually handled with the correct current state. This can be done by implementing a","category":"page"},{"location":"manual/#Outer-Handlers","page":"Manual","title":"Outer Handlers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To evaluate a Callable we need args and kwargs, hence there is also a custom handler CallableHandler(args...; kwargs...) to run Callable effects. We can just run it using explicit args, kwargs, but we can also reconstruct a true Callable.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO show how to reconstruct Callable manually","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Callable(function (args...; kwargs...)\n  runhandlers(CallableHandler(args...; kwargs...), eff)\nend)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We provide a convenience macro @runcallable which does just this, so you can write @runcallable eff.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO mention State and how it is different TODO show that both can be combined manual, however only like Callable(State(eff)).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TODO mention that @runcallable is actually smart enough to do this autmatically.","category":"page"},{"location":"manual/#Limitations","page":"Manual","title":"Limitations","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExtensibleEffects can do quite a lot, however what is not possible is to deal with infinite iterables. The reason is that ExtensibleEffects always run effects by translating them to operations on values (which then finally reduce the Effect Monad like Vector to the Identity Monad noeffect.). With an infinite iterable there is no way at all to extract all the values, hence they are not supported.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Compare this to a Callable. Also here, the value is hidden within the respective function, however we know how to principally get the value, namely by applying correct args and kwargs to the callable. Hence we can indeed operate on the value within a Callable, which lets us support Callable by ExtensibleEffects. Something like this is not possible with infinite iterables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ExtensibleEffects","category":"page"},{"location":"#ExtensibleEffects","page":"Home","title":"ExtensibleEffects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ExtensibleEffects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides an implementation of Extensible Effects. One concrete approach was presented in the paper Freer Monads, More Extensible Effects which already has an Haskell implementation as well as a Scala implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Julia implementation is massively simplified, and hence can also serve as a good introduction to get to know the details behind Extensible Effects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Many effects are provided, ranging from Option, which can be handled very simple, to the very limit of what can be supported by ExtensibleEffects - the State effect. Still, all the implementations are short and easy to follow, so look into the instances.jl file to see how to write your own Effect handlings.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
