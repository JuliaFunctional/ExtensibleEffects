var documenterSearchIndex = {"docs":
[{"location":"library/#ExtensibleEffects-Public-API","page":"Library","title":"ExtensibleEffects Public API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = ExtensibleEffects","category":"page"},{"location":"library/#Usage-and-Syntax","page":"Library","title":"Usage and Syntax","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Autorun","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@syntax_eff\n@syntax_eff_noautorun\nnoautorun","category":"page"},{"location":"library/#ExtensibleEffects.@syntax_eff","page":"Library","title":"ExtensibleEffects.@syntax_eff","text":"@syntax_eff begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nExtensible Effects syntax. It applies effect to all values which are not prefaced with @pure, which lifts them into the Eff monad.  The results are combined using @syntax_flatmap on the respective Eff monad, which finally is executed using autorun algorithm.\n\nExamples\n\nautohandled_eff = @syntax_eff begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nmycustomwrapper(i::Int) = collect(1:i)\n# monadic-like syntax to first apply a wrapper before interpreting code to unhandled effects\nautohandled_eff = @syntax_eff mycustomwrapper begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nThe Interface\n\nIf you want to add support for new types, you need to provide the following interface: (Vector is only an example)\n\ncore function description\nExtensibleEffects.eff_applies(handler::Type{<:Vector}, effectful::Vector) = true specify on which values the handler applies (the handler Vector applies to Vector of course)\nExtensibleEffects.eff_pure(handler::Type{<:Vector}, value) = [value] wrap a plain value into the Monad of the handler, here Vector.\nExtensibleEffects.eff_flatmap(continuation, effectful::Vector) apply a continuation to the current effect (here again Vector as an example). The key difference to plain TypeClasses.flatmap is that continuation does not return a plain Vector, but a Eff{Vector}. Applying this continuation with a plain map would lead Vector{Eff{Vector}}. However, eff_flatmap needs to return an Eff{Vector} instead.\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.@syntax_eff_noautorun","page":"Library","title":"ExtensibleEffects.@syntax_eff_noautorun","text":"@syntax_eff_noautorun begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nExtensible Effects syntax which does not run autorun routine. As @syntax_eff, it applies effect to all values which are not prefaced with @pure,  which lifts them into the Eff monad. The results are combined using @syntax_flatmap on the respective Eff monad, which then is directly returned.\n\nExamples\n\nunhandled_eff = @syntax_eff_noautorun begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\nmycustomwrapper(i::Int) = collect(1:i)\n# monadic-like syntax to first apply a wrapper before interpreting code to unhandled effects\nunhandled_eff = @syntax_eff_noautorun mycustomwrapper begin\n  a = [1,2,3]\n  b = [a, a*a]\n  @pure a, b\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.noautorun","page":"Library","title":"ExtensibleEffects.noautorun","text":"noautorun(handlers...)::Function\n\nConstructs a wrapper function which can be used within @syntax_eff to skip all given handler types within the autorun.\n\nExample\n\n@syntax_eff noautorun(Vector, Identity) begin\n  a = [1,2,3]\n  b = Identity(a + 2)\nend\n\nwill actually run no handler at all in the implicit autorun, as both handlers are marked for ignore.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Explicit introduction of effects","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"effect\nnoeffect","category":"page"},{"location":"library/#ExtensibleEffects.effect","page":"Library","title":"ExtensibleEffects.effect","text":"mark a value as an effect\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.noeffect","page":"Library","title":"ExtensibleEffects.noeffect","text":"mark a value as no effect, but plain value\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Explicit use of handlers","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"runhandlers\n@runhandlers","category":"page"},{"location":"library/#ExtensibleEffects.runhandlers","page":"Library","title":"ExtensibleEffects.runhandlers","text":"runhandlers(handlers, eff)\nrunhandlers((Vector, Option), eff)::Vector{Option{...}}\n\nrun all handlers such that the first handler will define the most outer container\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.@runhandlers","page":"Library","title":"ExtensibleEffects.@runhandlers","text":"@runhandlers handlers eff\n\nFor convenience we provide runhandlers function also as a macro.\n\nWith this you can easier run left-over handlers from an @syntax_eff autorun.\n\nExample\n\n@runhandlers WithCall(args, kwargs) @syntax_eff begin\n  a = Callable(x -> 2x)\n  @pure a\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#Interface","page":"Library","title":"Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Core Interface","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"eff_applies\neff_pure\neff_flatmap","category":"page"},{"location":"library/#ExtensibleEffects.eff_applies","page":"Library","title":"ExtensibleEffects.eff_applies","text":"ExtensibleEffects.eff_applies(handler::YourHandlerType, value::ToBeHandledEffectType) = true\n\nOverwrite this function like above to indicate that a concrete effect is handled by a handler. In most cases you will have YourHandlerType = Type{ToBeHandledEffectType}, like for Vector or similar.\n\nSometimes you need extra information without which you cannot run a specific effect. Then you need to link the specific handler containing the required information. E.g. Callable needs args and kwargs to be run, which are captured in the handler type CallableHandler(args, kwargs). Hence above you would choose YourHandlerType = CallableHandler, and ToBeHandledEffectType = Callable.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.eff_pure","page":"Library","title":"ExtensibleEffects.eff_pure","text":"ExtensibleEffects.eff_pure(handler, value)\n\nOverwrite this for your custom effect handler, return either ExtensibleEffects.Eff type, or a plain value. Plain values will be wrapped with noeffect automatically.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.eff_flatmap","page":"Library","title":"ExtensibleEffects.eff_flatmap","text":"ExtensibleEffects.eff_flatmap(handler, interpreted_continuation, value)\nExtensibleEffects.eff_flatmap(interpreted_continuation, value)\n\nOverwrite this for your custom effect handler to handle your effect. This function is only called if eff_applies(handler, value)==true.\n\nWhile for custom effects it is handy to dispatch on the handler itself, in simple cases handler == typeof(value) and hence, we allow to ommit it.\n\nParameters\n\nThe arg interpreted_continuation is guaranteed to return an Eff of the handled type. E.g. if you might handle the type Vector, you are guaranteed that interpreted_continuation(x)::ExtensibleEffects.Eff{Vector}\n\nReturn\n\nIf you do not return an ExtensibleEffects.Eff, the result will be wrapped into noeffect automatically, i.e. assuming the effect is handled afterwards.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"optional extra for autorun (in 99% not needed)","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"eff_autohandler","category":"page"},{"location":"library/#ExtensibleEffects.eff_autohandler","page":"Library","title":"ExtensibleEffects.eff_autohandler","text":"eff_autohandler(value) = Base.typename(typeof(value)).wrapper\n\nOverwrite this if the default autohandler extraction does not work for your case. E.g. for value::Vector the default would return Array, hence we need to overwrite it individually.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"for developing advanced effects like State","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"runhandler\nrunhandler_not_applies","category":"page"},{"location":"library/#ExtensibleEffects.runhandler","page":"Library","title":"ExtensibleEffects.runhandler","text":"runhandler(handler, eff::Eff)\nrunhandler(handler, eff::Eff, context)\n\nkey method to run an effect on some effecthandler Eff\n\nnote that we represent effectrunners as plain types in order to associate standard effect runners with types like Vector, Option, ...\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.runhandler_not_applies","page":"Library","title":"ExtensibleEffects.runhandler_not_applies","text":"runhandler_not_applies(handler, eff)\n\nif your handler does not apply, use this as the fallback to handle the unknown effect. \n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"for developing composable effect-handler-macros","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@insert_into_runhandlers","category":"page"},{"location":"library/#ExtensibleEffects.@insert_into_runhandlers","page":"Library","title":"ExtensibleEffects.@insert_into_runhandlers","text":"@insert_into_runhandlers outer_handler @syntax_eff begin\n  # ...\nend\n\nNext to simple Effects which can be directly composed down to plain values and reconstructed again from plain values, there are also a couple of more elaborate Effects, which values cannot be extracted without providing further context.\n\nCallables are a good example. It is impossible to extract the values of a callable without calling it, or without constructing another Callable around it.\n\nWith all these example the typical flow would be like\n\n\nCallable(function (args...; kwargs...)\n  callablehandler = CallableHandler(args...; kwargs...)\n\n  SomeOtherNeededContext() do info\n    otherhandler = SomeOtherHandler(info)\n\n    # ... possibly further nestings\n\n    @runhandlers (callablehandler, otherhandler #= possible further handlers =#) @syntax_eff begin\n      # ...\n    end\n  end\nend)\n\n@inser_into_runhandlers can be used to simplify and even separate these outer handlers from one another, so that they can be used as composable interchangeable macros.\n\nFor example, here the implementation of @runcallable (ignoring macro hygiene)\n\nmacro runcallable(expr)\n  :(Callable(function(args...; kwargs...)\n    @insert_into_runhandlers(CallableHandler(args...; kwargs...), $expr)\n  end))\nend\n\nThis will search for an existing call to runhandlers within the given expr, and if found, inserts the CallableHandler similar to the motivating example above. If no runhandlers is found, it will create a new one.\n\nThis way, you can compose the nested code-structures very easily. You only have to be careful, that you always run all outer effects at once, in one single statement, so that @insert_into_runhandlers can actually find the right runhandlers.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Effect-Handlers","page":"Library","title":"Effect Handlers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Writer","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"WriterHandler","category":"page"},{"location":"library/#ExtensibleEffects.WriterHandler","page":"Library","title":"ExtensibleEffects.WriterHandler","text":"WriteHandler(pure_accumulator=neutral)\n\nHandler for generic Writers. The default accumulator works with Option values.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Callable","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"CallableHandler\n@runcallable","category":"page"},{"location":"library/#ExtensibleEffects.CallableHandler","page":"Library","title":"ExtensibleEffects.CallableHandler","text":"CallableHandler(args...; kwargs...)\n\nHandler for functions, providing the arguments and keyword arguments for calling the functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.@runcallable","page":"Library","title":"ExtensibleEffects.@runcallable","text":"@runcallable(eff)\n\ntranslates to\n\nCallable(function(args...; kwargs...)\n  @insert_into_runhandlers CallableHandler(args...; kwargs...) eff\nend)\n\nThanks to @insert_into_runhandlers this outer runner can compose well with other outer runners.\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"State","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"StateHandler\n@runstate","category":"page"},{"location":"library/#ExtensibleEffects.StateHandler","page":"Library","title":"ExtensibleEffects.StateHandler","text":"StateHandler(state)\n\nHandler for running State. Gives the initial state.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.@runstate","page":"Library","title":"ExtensibleEffects.@runstate","text":"@runstate eff\n\nNote that unlike Callable, a State has to ensure that it is always the first outer Eff being run, as it returns the inner state as an additional argument.\n\nIf you would nest it with runcallable, e.g. like @runstate @runcallable eff it wouldn't work, as now the appended state is within the Callable and not directly within the State.\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"ContextManager","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"ContextManagerHandler\n@runcontextmanager\n@runcontextmanager_\nContextManagerCombinedHandler","category":"page"},{"location":"library/#ExtensibleEffects.ContextManagerHandler","page":"Library","title":"ExtensibleEffects.ContextManagerHandler","text":"ContextManagerHandler(continuation)\n\nHandler for DataTypesBasic.ContextManager.\n\nThe naive handler implementation for contextmanager would immediately run the continuation within the contextmanager. However this does not work, as handling one effect does not mean that all \"inner\" effects are already handled. Hence, such a handler would actually initialize and finalize the contextmanager, without its value being processed already. When the other \"inner\" effects are run later on, they would find an already destroyed contextmanager session. We need to make sure, that the contextmanager is really the last Effect run. Therefore we create a custom handler.\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.@runcontextmanager","page":"Library","title":"ExtensibleEffects.@runcontextmanager","text":"@runcontextmanager(eff)\n\ntranslates to\n\nContextManager(function(cont)\n  @insert_into_runhandlers ContextManagerHandler(cont) eff\nend)\n\nThanks to @insert_into_runhandlers this outer runner can compose well with other outer runners.\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.@runcontextmanager_","page":"Library","title":"ExtensibleEffects.@runcontextmanager_","text":"@runcontextmanager_(eff)\n\nlike @runcontextmanager(eff), but immediately runs the final ContextManager\n\n\n\n\n\n","category":"macro"},{"location":"library/#ExtensibleEffects.ContextManagerCombinedHandler","page":"Library","title":"ExtensibleEffects.ContextManagerCombinedHandler","text":"ContextManagerCombinedHandler(otherhandler)\n\nWe can combine ContextManager with any other Handler. This is possible because ContextManager, within eff_flatmap, does not constrain the returned eff of the continuation.\n\n\n\n\n\n","category":"type"},{"location":"library/#Internals","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Core DataTypes","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Eff\nContinuation\nNoEffect","category":"page"},{"location":"library/#ExtensibleEffects.Eff","page":"Library","title":"ExtensibleEffects.Eff","text":"central data structure which can capture Effects in a way that they can interact, while each is handled independently on its own\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.Continuation","page":"Library","title":"ExtensibleEffects.Continuation","text":"only for internal purposes, captures the still unevaluated part of an Eff\n\n\n\n\n\n","category":"type"},{"location":"library/#ExtensibleEffects.NoEffect","page":"Library","title":"ExtensibleEffects.NoEffect","text":"special Wrapper, which is completely peeled of again\n\nComparing to Identity, Identity{T} results in Identity{T}, while NoEffect{T} results in plain T.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"autorun","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"autorun\nNoAutoRun","category":"page"},{"location":"library/#ExtensibleEffects.autorun","page":"Library","title":"ExtensibleEffects.autorun","text":"autorun(eff)\n\nspecial effectrunner which recognizes effecttypes used within eff and calls the effects in order, such that the first effect found will at the end be the most outer container, and the last different effect found will be the most inner container of the result value.\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.NoAutoRun","page":"Library","title":"ExtensibleEffects.NoAutoRun","text":"Wrapper to indicate that a given handler should not be handled within autorun\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"other","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"runhandler\nrunlast\nrunlast_ifpossible","category":"page"},{"location":"library/#ExtensibleEffects.runlast","page":"Library","title":"ExtensibleEffects.runlast","text":"runlast(eff::Eff)\n\nextract final value from Eff with all effects (but Identity) already run\n\n\n\n\n\n","category":"function"},{"location":"library/#ExtensibleEffects.runlast_ifpossible","page":"Library","title":"ExtensibleEffects.runlast_ifpossible","text":"runlast_ifpossible(eff::Eff)\n\nlike ExtensibleEffects.runlast, however if the Eff is not yet completely handled, it just returns it.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"CurrentModule = ExtensibleEffects\nDocTestSetup  = quote\n    using ExtensibleEffects\nend","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Welcome to ExtensibleEffects.jl. This package provides an implementation of Extensible Effects. We follow the approach presented in the paper Freer Monads, More Extensible Effects which already has an Haskell implementation as well as a Scala implementation.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This Julia implementation is massively simplified, and hence can also serve as a good introduction to get to know the details behind Extensible Effects.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many effects are provided, ranging from Option, which can be handled very simple, to the very limit of what can be supported by ExtensibleEffects - the State effect. Still, all the implementations are short and easy to follow, so look into the instances.jl file to see how to write your own Effect handlings.","category":"page"},{"location":"manual/#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Pkg\npkg\"add ExtensibleEffects\"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Use it like","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using ExtensibleEffects","category":"page"},{"location":"manual/#eff_applies,-eff_pure,-eff_flatmap","page":"Manual","title":"eff_applies, eff_pure, eff_flatmap","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Vector, Iterable and many more are handled by overwriting the three core functions. We specify them by using Vector as an example:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"core function default description\neff_applies(handler::Type{<:Vector}, effectful::Vector) = true there is no default specify on which values the handler applies (the handler Vector applies to Vector of course)\neff_pure(handler::Type{<:Vector}, value) = [value] defaulting toTypeClasses.pure (enough for Vector) wrap a plain value into the Monad of the handler, here Vector.\neff_flatmap(continuation, effectful::Vector) defaults to usingmap, flatmap, and flip_types from TypeClasses (this is enough for Vector) apply a continuation to the current effect (here again Vector as an example). The key difference to plainTypeClasses.flatmap is that continuation does not return a plain Vector, but a Eff{Vector}. Applying this continuation with a plain map would lead Vector{Eff{Vector}}. However, eff_flatmap needs to return an Eff{Vector} instead.","category":"page"},{"location":"manual/#More-Complex-ExtensibleEffect-Handlers","page":"Manual","title":"More Complex ExtensibleEffect Handlers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"While Vector, and Iterable have almost trivial implementations, Identity and Const, i.e. Option, Try and Either, need a bit more interaction with the effect system.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The design decision of unifying Option/Try/Either by separating normal behaviour into Identity and stopping behaviour into Const has many advantages. One difficulty, however, is that Const does not have a TypeClasses.pure implementation, so how do we define eff_pure? The answer is an important insight into how ExtensibleEffects work: The pure function is only called on the final values within all the nested eff_flatmap calls. After destructuring all nested effects into plain values, the effects get rewrapped around the plain values. A Const, however, is always constant - there is no inner value to work on. That is why we freely use any eff_pure definition, as it will never be used in case of a Const. The simplest version is to do nothing. All in all this is the implementation for Const","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nExtensibleEffects.eff_flatmap(continuation, a::Const) = a\nExtensibleEffects.eff_pure(handler::Type{<:Const}, a) = a\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You see, the continuation is ignored and the pure just returns the very same value.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The interaction between Const and Identity needs to be handled in addition. If something would return a Const the default implementation of eff_pure for Identity would wrap it into an Identity layer, resulting into Identity(Const(...)). This differs from the TypeClasses.flatmap implementation which would return just a Const(...). This interaction is crucial for Option/Try/Either. We can implement it by special casing the eff_pure","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExtensibleEffects.eff_pure(handler::Type{<:Identity}, a) = Identity(a)\nExtensibleEffects.eff_pure(handler::Type{<:Identity}, a::Const) = a\n\nExtensibleEffects.eff_flatmap(continuation, a::Identity) = continuation(a.value)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Take a look at the definition of eff_flatmap for Identity. eff_flatmap gets a continuation which when called returns an Eff{YourEffectType{Value}} and should always return an Eff{YourEffectType{Value}} as well, i.e. Eff{Identity{Value}}in our case. Usually it is quite difficult to apply the continuation and return the same type, but for Identity the case is super simple, as we can just strip away the one Identity layer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, in case you disable the default autorun feature, you may also want to use Option/Try/Either as the handlers instead of specifying the two handlers Identity and Const separately. This is enabled by explicitly defining eff_applies and forwarding the eff_pure to the case for Identity.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExtensibleEffects.eff_applies(handler::Type{<:Either}, value::Either) = true\nExtensibleEffects.eff_pure(handler::Type{<:Either}, a) = ExtensibleEffects.eff_pure(Identity, a)  # Const would never reach this\n","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All these can still be run automatically, without any further context parameters. In ExtensibleEffect terms, this means that Option, Vector, Iterable and the like are handlers by its own and can be autorun.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We acknowledge this everytime we define eff_applies like such ExtensibleEffects.eff_applies(handler::Type{<:HandlerType}, value::HandlerType) = true.","category":"page"},{"location":"manual/#Handlers-With-Additional-Parameters","page":"Manual","title":"Handlers With Additional Parameters","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The Writer monad is actually similar to Vector when using its default accumulator TypeClasses.neutral.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> @syntax_eff begin\n         a = Writer(\"hello.\", 1)\n         b = Writer(\"world.\", 2)\n         @pure a + b\n       end\nWriter{String, Int64}(\"hello.world.\", 3)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"However, if you want to use another accumulator as the default one, extra adaptations are required. Unlike Option such a parameter cannot be added by simply overloading eff_pure or the like, but we need an extra handler type which can carry all additional information needed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> @runhandlers (WriterHandler(\"pure-accumulator.\"), Vector) @syntax_eff_noautorun begin\n         a = Writer(\"hello.\", 1)\n         b = Writer(\"world.\", 2)\n         c = [3, 4]\n         @pure a + b + c\n       end\nWriter{String, Vector{Int64}}(\"hello.world.pure-accumulator.\", [6, 7])\n\njulia> @runhandlers (Vector, WriterHandler(\"pure-accumulator.\")) @syntax_eff_noautorun begin\n         a = Writer(\"hello.\", 1)\n         b = Writer(\"world.\", 2)\n         c = [3, 4]\n         @pure a + b + c\n       end\n2-element Vector{Writer{String, Int64}}:\n Writer{String, Int64}(\"hello.world.pure-accumulator.\", 6)\n Writer{String, Int64}(\"hello.world.pure-accumulator.\", 7)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The example may be slightly artifical, however you can see nicely, how the eff_pure function works differently when using an explicit WriteHandler handler.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The handler is defined by","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct WriterHandler{Acc}\n  pure_acc::Acc\nend\nExtensibleEffects.eff_applies(handler::WriterHandler{Acc}, value::Writer{Acc}) where Acc = true\nExtensibleEffects.eff_pure(handler::WriterHandler, value) = Writer(handler.pure_acc, value)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Take a look again at the above example which runs both WriterHandler and Vector. It gives you feeling of when eff_pure is called internally, namely only when reconstructing the respective effect layer. You do not see multiple \"pure-accumulator.\" accumulating for each single value. Instead you have tight control about whether first the indeterminism by Vector should be run and then the accumulator by Writer or the other way arround. Either way, in both cases everything is sound and nice.","category":"page"},{"location":"manual/#Outer-Handlers","page":"Manual","title":"Outer Handlers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are other Monads which really require external parameters to be run at all. One such monad is Callable, i.e. plain functions. A function needs to be called to get at its value, however with which args and kwargs should the function be called? These need to be given somehow, and hence we require for a specific handler like seen for WriterHandler. It is called CallableHandler and is defined as follows","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct CallableHandler{Args, Kwargs}\n  args::Args\n  kwargs::Kwargs\nend\nExtensibleEffects.eff_applies(handler::CallableHandler, value::Callable) = true\nExtensibleEffects.eff_pure(handler::CallableHandler, a) = a\nfunction ExtensibleEffects.eff_flatmap(handler::CallableHandler, continuation, a::Callable)\n  continuation(a(handler.args...; handler.kwargs...))\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In addition, we would like to construct a Callable as the return value, i.e. wrapping everything into a Function itself which asks for the args and kwargs. We do this by a special macro @runcallable which can be composed with other such outer wrappers thanks to the ExtensibleEffects.@insert_into_runhandlers helper macro.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@runcallable eff","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"translates to","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Callable(function(args...; kwargs...)\n  @insert_into_runhandlers CallableHandler(args...; kwargs...) eff\nend)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Types like Callable cannot be autorun, and thankfully, ExtensibleEffects can recognize this automatically. All in all we get","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> f = @runcallable @syntax_eff begin\n         a = Callable(x -> x*x)\n         b = Callable(x -> 2x)\n         @pure a + b\n       end;\n\njulia> f(7)\n63","category":"page"},{"location":"manual/#Outer-Handler-ContextManager-and-the-execution-order","page":"Manual","title":"Outer Handler - ContextManager and the execution order","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Another example for a Monad which requires an outer handler is the ContextManager type from DataTypesBasic.jl. It needs to continuation to be run, and ideally should return everything wrapped into a new ContextManager so that the executions can be lazy. Very analogous to the requirements of Callable. And indeed there is ContextManagerHandler(continuation) and @runcontextmanager, just like for Callable. There is one extra caveat which is very special to ContextManagers and that is the execution order.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It turns out, ContextManager is actually one of the most difficult computational contexts to be represented within Extensible Effects. This is because, within Eff the continuations always return another Eff, within which other effects still need to be handled. The computation inside was not fully executed and is hold frozen for later execution. However, the ContextManager semantics really depend on the assumption, that whatever uses the internal value has finished before the ContextManager exits. Otherwise resource may have been destroyed before they are actually used.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The only way to solve this conflict is that the contextmanager handler needs to run last. This is actually checked by the ContextManagerHandler, however as @runcontextmanager wraps everything again into a lazy ContextManager, you need to run it to see the error.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There is further a special handler ContextManagerCombinedHandler which improves the execution order for memory performance. Let's have a simple factory for ContextManagers for example purposes","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> create_context(x) = @ContextManager continuation -> begin\n           println(\"before $x\")\n           result = continuation(x)\n           println(\"after $x\")\n           result\n       end\ncreate_context (generic function with 1 method)\n\njulia> println_return(x) = (println(x); x)\nprintln_return (generic function with 1 method)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Using ContextManagerHandler we get","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> eff = @syntax_eff begin\n         a = [100,200]\n         b = create_context(a)\n         c = [5,6]\n         d = create_context(a + c)\n         @pure a, b, c, d\n       end;\n\njulia> @runhandlers (ContextManagerHandler(println_return),) eff\nbefore 100\nbefore 105\nbefore 106\nbefore 200\nbefore 205\nbefore 206\n[(100, 100, 5, 105), (100, 100, 6, 106), (200, 200, 5, 205), (200, 200, 6, 206)]\nafter 206\nafter 205\nafter 200\nafter 106\nafter 105\nafter 100\n4-element Vector{NTuple{4, Int64}}:\n (100, 100, 5, 105)\n (100, 100, 6, 106)\n (200, 200, 5, 205)\n (200, 200, 6, 206)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Alternatively, we can use a combined handler ContextManagerCombinedHandler which runs both handlers at once. Intuitively you may think this cannot change anything, but indeed quite a lot is changed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> eff = @syntax_eff noautorun(Vector) begin\n         a = [100,200]\n         b = create_context(a)\n         c = [5,6]\n         d = create_context(a + c)\n         @pure a, b, c, d\n       end\nEff(effectful=[100, 200], length(cont)=1)\n\njulia> handlers = (ContextManagerCombinedHandler(Vector, println_return),)\n(ContextManagerCombinedHandler{Type{Vector{T} where T}, typeof(println_return)}(Vector{T} where T, ContextManagerHandler{typeof(println_return)}(println_return)),)\n\njulia> @runhandlers handlers eff\nbefore 100\nbefore 105\n(100, 100, 5, 105)\nafter 105\nbefore 106\n(100, 100, 6, 106)\nafter 106\nafter 100\nbefore 200\nbefore 205\n(200, 200, 5, 205)\nafter 205\nbefore 206\n(200, 200, 6, 206)\nafter 206\nafter 200\n4-element Vector{NTuple{4, Int64}}:\n (100, 100, 5, 105)\n (100, 100, 6, 106)\n (200, 200, 5, 205)\n (200, 200, 6, 206)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The difference lies in the different continuations which are created internally during the run of the handler. When the Vector handler was run independently beforehand, the ContextManagerHandler worked with far larger continuations, which actually reached up to the end of the entire computation. Now when running both handlers at once, the continuation is more intuitive, namely the one which only goes up to the end of the for loop iteration (thinking of Vector handling like for loop execution).","category":"page"},{"location":"manual/#Handlers-which-need-to-be-updated-from-one-effect-to-another","page":"Manual","title":"Handlers which need to be updated from one effect to another","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The most advanced possibility to define effects is showcased by State. It needs a custom handler which provides the initial state information StateHandler(state), similar to Callable. In addition, every effect actually adapts the state, and hence the handler itself must be updated accordingly so that subsequent effects are actually handled with the correct current state. This can be done by implementing your individual ExtensibleEffects.runhandler method. Let's take a look on how StateHandler is implemented.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct StateHandler{T}\n  state::T\nend\nExtensibleEffects.eff_applies(handler::StateHandler, value::State) = true\nExtensibleEffects.eff_pure(handler::StateHandler, value) = (value, handler.state)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The type is very simple, it just stores the initial or current state. eff_applies and eff_pure are defined the standard way.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now comes the trick to pass on the internal states","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function ExtensibleEffects.runhandler(handler::StateHandler, eff::Eff)\n  eff_applies(handler, eff.effectful) || return runhandler_not_applies(handler, eff)\n  \n  nextvalue, nextstate = eff.effectful(handler.state)\n  nexthandler = StateHandler(nextstate)\n  if isempty(eff.cont)\n    _eff_pure(nexthandler, nextvalue)\n  else\n    runhandler(nexthandler, eff.cont(nextvalue))\n  end\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExtensibleEffects.runhandler is the key function to overwrite if you would like to define what happens between evaluations of your effectful type.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first line checks whether our handler StateHandler actually applies to the given effectful, and if not, we return the result of a helper function runhandler_not_applies.\nEverything which follows implements the case that our handler applies and hence assumes that eff.effectful is of type State.\nWe run the State, given our previous state from the handler, and get the nextstate which we use to construct the nexthandler.\nDepending on whether the given eff possibly contains further State types, we either stop with _eff_pure, or recurse into runhandler again.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, similar to Callable and ContextManager there also exists a run macro for State, called runstate, which will wrap everything into a State within which the StateHandler is run. Seeing everything it in action looks like","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> state_eff = @runstate @syntax_eff begin\n         a = State(x -> (x+2, x*x))\n         b = State(x -> (a + x, x+1))\n         @pure a, b\n       end;\n\njulia> state_eff(3)\n((5, 14), 10)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that unlike Callable and ContextManager, a State always has to ensure that it is the first outer wrapper being run, because it returns the inner state as an additional argument.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you would nest it within  @runcallable, e.g. like @runstate @runcallable eff it wouldn't work, as now the appended state is within the Callable and not directly within the State.","category":"page"},{"location":"manual/#Combining-wrappers-like-@runcallable,-@runcontextmanager-and-@runstate","page":"Manual","title":"Combining wrappers like @runcallable, @runcontextmanager and @runstate","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Within the ExtensibleEffects framework, different handlers naturally compose nicely in order to execute all the given effects. Constructing wrappers around the solution, like it does @runcallable for example, is not part of the standard extensible effects framework. Nevertheless, especially if you want to replace Monads (TypeClasses.jl) with ExtensibleEffects.jl, being able to construct these wrappers easily creates a very intuitive plug-and-play interface. Further we would like to compose them, too.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In order to compose such wrappers, we currently use a macro approach. Each wrapper (including custom ones) constructs its wrapper-code using macros. Take a look at @runcallable again. It is defined like","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"macro runcallable(expr)\n  esc(:(Callable(function(args...; kwargs...)\n    @insert_into_runhandlers CallableHandler(args...; kwargs...) ($expr)\n  end)))\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"i.e.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@runcallable eff","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"translates to","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Callable(function(args...; kwargs...)\n  @insert_into_runhandlers CallableHandler(args...; kwargs...) eff\nend)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@insert_into_runhandlers will expand all inner macros and search for a call to runhandlers in order to insert the newly constructed CallableHandler. If no runhandlers is found, it will call it itself.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Using this style, all wrappers can be written very concisely and combined in arbitrary order (in principle). There is an alternative way of implementation which uses nested functions instead of macros, however the syntax would look more polluted and we haven't yet seen crucial disadvantages of the macro approach.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As @runstate needs always be run first and @runcontextmanager needs to run last, in our concrete example though the order is given by the semantics of the wrappers. It would be @runcontextmanager @runcallable @runstate","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> contextmanager_callable_state = @runcontextmanager @runcallable @runstate @syntax_eff begin\n         co = create_context(42)\n         st = State(s -> (co+s, s*s))\n         ca = Callable(x -> x + st + co)\n         @pure co, st, ca\n       end;\n\njulia> typeof(contextmanager_callable_state).name\ntypename(ContextManager)\n\njulia> typeof(contextmanager_callable_state(println_return)).name\ntypename(Callable)\n\njulia> typeof(contextmanager_callable_state(println_return)(3)).name\ntypename(State)\n\njulia> contextmanager_callable_state(println_return)(3)(9)\nbefore 42\n((42, 51, 96), 81)\nafter 42\n((42, 51, 96), 81)","category":"page"},{"location":"manual/#Limitations","page":"Manual","title":"Limitations","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExtensibleEffects can do quite a lot, however some things are just not possible.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One such limitation are infinite iterables. They are not supportable. The reason is that ExtensibleEffects always run effects by translating them to operations on plain values. With an infinite iterable there is no way to extract all the values though. If you know more about your infite iterable, it my get possible again. For instance it could be a simple infinite repetition of the same element. In such cases we indeed can extract \"all\" values at once, operate on it, and reconstruct the repeating iterable around it.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A second limitation is that we need to know a way to wrap a plain value into our handled effect. While we can always make an a into an [a], it is not possible to wrap it into a Dict for instance. Which key would you choose? In general, a function like this is called pure, and it is needed because ExtensibleEffects work by first breaking down everything into values before reconstructing the respective effects from scratch.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Compare both limitations to the fully supported Callable type. Also here, the value is hidden within the respective function, however we know how to principally get the value, namely by applying correct args and kwargs to the callable. Hence we can indeed operate on the value within a Callable, which lets us support Callable by ExtensibleEffects. Something like this is not possible with infinite iterables. Also we can wrap a value into a Callable by creating a constant function (args...; kwargs...) -> a, which is not possible for a dictionary.","category":"page"},{"location":"manual/#How-does-it-actually-work?","page":"Manual","title":"How does it actually work?","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ExtensibleEffects put everything into the meta monad Eff and somehow magically by doing so different monads can compose well together.","category":"page"},{"location":"manual/#Key-ingredients","page":"Manual","title":"Key ingredients","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are two main ingredience for this magic to work:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Eff is itself a Monad, hence you can work within Eff without caring about the precise workings of the computational context Eff.\nEff is not only an arbitrary Monad, but a very generic one, sometimes called a kind of free Monad. The key result is that we can represent many many of our well known Monads into this Eff monad.\nThe ExtensibleEffects system guarantees that the continuation in eff_flatmap(handler, continuation, effectful) will always return an Eff with element type of the same type as effectful itself. This makes it possible to define your own effect-handlers independent of all the other effect-handlers.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The monad implementation is very simple indeed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TypeClasses.pure(::Type{<:Eff}, a) = noeffect(a)\nTypeClasses.map(f, eff::Eff) = TypeClasses.flatmap(noeffect ∘ f, eff)\nTypeClasses.flatmap(f, eff::Eff) = Eff(eff.effectful, Continuation(eff.cont.functions..., f))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In brief, it just stores all functions for later execution in the Continuation attribute cont. The first function in the Continuation is later applied directly to the eff.effectful, the second function in cont is applied to the result of the first function, the third to the result of that, and so forth (with the addition that all functions return Eff which wrap the results). That is it.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's look at the third ingredient, why the continuation always returns an Eff of the very same type.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"What is actually the element type of an Eff? It is not the typeparameter Eff{ElementType}, because Eff is defined as Eff{Effectful, Continuation}. We can nevertheless get an intuitive feeling for the element type: When using map/flatmap like in","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"flatmap(eff) do value\n  # ...\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The element is the argument to our anonymous function which we map over the container. For example above, the element type would be typeof(value).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For Eff the value of flatmap is specified by whatever function is mapped right befor our call to map. To understand what this is, we need to take a look into whatever is calling our eff_flatmap. It turns out this is ExtensibleEffects.runhandler. Here is its definition:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function runhandler(handler, eff::Eff)\n  eff_applies(handler, eff.effectful) || return runhandler_not_applies(handler, eff)\n\n  interpreted_continuation = if isempty(eff.cont)\n    # `_eff_pure` just calls `eff_pure` and ensures that the return value is of type `Eff`\n    Continuation(x -> _eff_pure(handler, x))\n  else\n    Continuation(x -> runhandler(handler, eff.cont(x)))\n  end\n  # `_eff_flatmap` just calls `eff_flatmap` and ensures that the return value is of type `Eff`\n  _eff_flatmap(handler, interpreted_continuation, eff.effectful)\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is quite similar to our custom handler we wrote for State. In the first line we again check whether our current handler actually applies. For our purposes at the moment, we are only interested in the case where it applies, so we can go on to line 3: Here we construct the actual continuation which is then passed to eff_flatmap. The last line then is already our call to eff_flatmap which we wanted to understand in more detail.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's summarize the situation and the goal again. It is simpler to follow if we take concrete example. Let's consider that eff.effectful is of type Vector, and that also handler = Vector. We want to understand why the continuation, here interpreted_continuation, is returning an Eff with element type Vector as well.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Looking at the definition of interpreted_continuation we can directly read out its return value.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In the first case, if isempty(eff.cont), we get an _eff_pure(Vector, ...) which indeed will construct an Eff with element type Vector (the continuation of that Eff is still empty).\nIn the second case we get runhandler(Vector, eff.cont(x)), which recurses into our very function runhandler itself. What does it return?\nIf the Vector handler applies to the next effect eff.cont(x)::Eff, we return eff_flatmap(...). Remember eff_flatmap belongs to the core interface and indeed for Vector always return an Eff of element type Vector, if everything goes right.\nIf the Vector handler does not apply to the next effect eff.cont(x), we return runhandler_not_applies(Vector, eff). Here is its definition\nfunction runhandler_not_applies(handler, eff::Eff)\n  interpreted_continuation = if isempty(eff.cont)\n    Continuation(x -> _eff_pure(handler, x))\n  else\n    Continuation(x -> runhandler(handler, eff.cont(x)))\n  end\n  Eff(eff.effectful, interpreted_continuation)\nend\nThe interpreted_continuation is constructed exactly identically. The only difference is that instead of calling eff_flatmap, we construct an Eff which will remember to run our handler for subsequent effects. We are interested in the element type of this returned Eff, which is directly defined by what interpreted_continuation returns, same as before.\nIn the first case we have _eff_pure(Vector, ...) again, which is an Eff of element type Vector.\nIn the second case we recurse one more time into our well known runhandler(Vector, ...), what does it return? At this point we already have been once. We have seen all branches our function can take: There was the _eff_pure(Vector, ...) branch, which is returning an Eff of element type Vector quite trivially. There was _eff_flatmap which does so as well by definition. Finally there is the recursion branch. Assuming now that the recursion ends, it will itself end in branch one or two and hence also return an Eff of element type Vector.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To emphasize one implicit but very important aspect of the above argument: Whether things are actually computed or just stored for later execution, to understand which element type the Eff has it is not decisive. Everything which matters is what is going to be executed right before. This way the different handlers can actually stack their computations on top of each other without interferring.","category":"page"},{"location":"manual/#Extensive-Advanced-Example","page":"Manual","title":"Extensive Advanced Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally let's look at a concrete example of running two simple handlers, Vector and Writer.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> @syntax_eff begin\n         a = [2, 3]\n         b = Writer(\"hello.\", a*a)\n         c = [7, 8]\n         d = Writer(\"world.\", a+b+c)\n         @pure a, b, c, d\n       end\n4-element Vector{Writer{String, NTuple{4, Int64}}}:\n Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13))\n Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 8, 14))\n Writer{String, NTuple{4, Int64}}(\"hello.world.\", (3, 9, 7, 19))\n Writer{String, NTuple{4, Int64}}(\"hello.world.\", (3, 9, 8, 20))\n\njulia> eff = @syntax_eff_noautorun begin\n         a = [2, 3]\n         b = Writer(\"hello.\", a*a)\n         c = [7, 8]\n         d = Writer(\"world.\", a+b+c)\n         @pure a, b, c, d\n       end\nEff(effectful=[2, 3], length(cont)=1)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"@syntax_eff uses autorun and hence is just the same as manually running @runhandlers (Vector, Writer) @syntax_eff_noautorun ..., which again translates into","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"import ExtensibleEffects: runhandler, runlast_ifpossible, Continuation\nrunlast_ifpossible(runhandler(Vector, runhandler(Writer, eff)))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"where eff refers to the above variable storing the result of @syntax_eff_noautorun. Let's go step by step:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"we start with runhandler(Writer, eff)\nthe first effect found is not of type Writer, and the Eff has still a continuation left, i.e. eff.cont is not empty. Hence we construct Eff(eff.effectful, interpreted_continuation_Writer1) where interpreted_continuation_Writer1 recurses into runhandler using the handler Writer. The inner eff.cont is the very first continuation, capturing the entire computation.\noriginal_continuation1(a) = @syntax_eff_noautorun begin\n  b = Writer(\"hello.\", a*a)\n  c = [7, 8]\n  d = Writer(\"world.\", a+b+c)\n  @pure a, b, c, d\nend\n\ninterpreted_continuation_Writer1(a) = runhandler(Writer, original_continuation1(a))\neff2 = runhandler(Writer, eff) already returns\nrunhandler(Vector, eff2) is run\nthe first effect found is of type Vector, and the eff2.cont is again non-empty - it is just our interpreted_continuation_Writer1. Hence we will construct a new continuation, let's call it interpreted_continuation_Vector1, which recurses into runhandler using the handler Vector. We can specify it more concretely as\ninterpreted_continuation_Vector1 = Continuation(x -> runhandler(Vector, interpreted_continuation_Writer1(x)))\nthis interpreted_continuation_Vector1 is now passed to eff_flatmap for Vector which will call this continuation for all values, here 2 and 3.\ninterpreted_continuation_Vector1(2) returns the results of this first branch, which is now a pure value (which you can see at length(cont)=0)\njulia> interpreted_continuation_Vector1(2)\nEff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 4, 10)), Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 5, 11))]), length(cont)=0)\nLet's look into interpreted_continuation_Writer1(2)\njulia> eff3 = interpreted_continuation_Writer1(2)\nEff(effectful=[4, 5], length(cont)=2)\nGiven a = 2, the original program could continue and returned an Eff with the first Writer as its effectful value and all the rest as the continuation.\nfunction original_continuation2(b)\n  a = 2\n  @syntax_eff_noautorun begin\n    c = [7, 8]\n    d = Writer(\"world.\", a+b+c)\n    @pure a, b, c, d\n  end\nend\nThen runhandler(Writer, ...) was called on top if it, finding an effectful Writer and non-empty continuation original_continuation2 and hence constructing a new continuation\ninterpreted_continuation_Writer2 = Continuation(x -> runhandler(Writer, original_continuation2(x)))\nwhich is then passed to eff_flatmap.\nWithin eff_flatmap, the Writer's inner value is extracted, a 4 = 2*2, and passed on to the continuation.\njulia> interpreted_continuation_Writer2(4)\nEff(effectful=[7, 8], length(cont)=1)\nHere what happened step by step:\neff4 = original_continuation2(4) was called, returning the next program step Eff(effectful=[4, 5], length(cont)=1)\nrunhandler(Writer, eff4) found a Vector which it cannot handle, and in addition the Effect has a non-empty continuation. Hence it returns an Eff with the same effectful (the Vector here) and applying runhandler(Writer, ...) to the continuation.\nfunction original_continuation3(c)\n  a = 2\n  b = 4\n  @syntax_eff_noautorun begin\n    d = Writer(\"world.\", a+b+c)\n    @pure a, b, c, d\n  end\nend\n\ninterpreted_continuation_Writer3 = Continuation(x -> runhandler(Writer, original_continuation3(x)))\nThat is also why the length of eff.cont hasn't changed. original_continuation3 was simply replaced with interpreted_continuation_Writer3.\nfinally eff_flatmap for Writer will work within the returned Eff using Eff' monad-power, and combine its accumulator to the accumulator of the going-to-be Writer within the Eff.\nfunction ExtensibleEffects.eff_flatmap(continuation, a::Writer)\n  eff_of_writer = continuation(a.value)\n  map(eff_of_writer) do b\n    Writer(a.acc ⊕ b.acc, b.value)\n  end\nend\nAs Eff does not actually compute anything, but just stores the computation for later execution by appending it to eff.cont, we arrive at our final result\njulia> eff3 = interpreted_continuation_Writer1(2)\nEff(effectful=[7, 8], length(cont)=2)\nrunhandlers(Vector, eff3)\nit will find an effectful of the correct type and a non-empty continuation, hence creating a continuation\ninterpreted_continuation_Vector2(x) = runhandler(Vector, eff3.cont(x))\nand passing it to eff_flatmap\neff_flatmap will now run it for both of its values 7 and 8, starting with 7\neff3.cont(7) gives a pure result (length(cont)=0) of type NoEffect{Writer}. Note that this is not a Writer effect, but really the end-result which gets wrapped into the trivial effect NoEffect.\njulia> eff3.cont(7)\nEff(effectful=NoEffect{Writer{String, NTuple{4, Int64}}}(Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13))), length(cont)=0)\nHow does this came about?\neff3.cont contains two continuations, the first was interpreted_continuation_Writer3 (original_continuation3 followed by runhandler(Writer, ...)) and the second came from the extra map operation from within Writer's eff_flatmap operation.\neff5 = original_continuation3(7) just continues our original program\njulia> original_continuation3(7)\nEff(effectful=Writer{String, Int64}(\"world.\", 13), length(cont)=1)\nThe continuation in here is just the last part of our program\nfunction original_continuation4(d)\n  a = 2\n  b = 4\n  c = 7\n  # the following is invalid syntax, because julia cannot typeinfer the effect type which would be needed to call `pure`\n  # @syntax_eff_noautorun begin\n  #   @pure a, b, c, d\n  # end\n\n  # instead we can construct pure manually\n  noeffect((a, b, c, d))\nend\ninterpreted_continuation_Writer3(7) is just runhandler(Writer, eff5). The Writer handler finds a matching effectful and non-empty continuation, hence creating a new continuation\ninterpreted_continuation_Writer4(x) = runhandler(Writer, original_continuation4(x))\nwhich is then passed into Writer's eff_flatmap\neff_flatmap extracts the value from the current Writer, which is 13 here, and passes it to the continuation\nThe original continuation returns a NoEffect effect type which contains the final Tuple\njulia> eff6 = original_continuation4(13)\nEff(effectful=NoEffect{NTuple{4, Int64}}((2, 4, 7, 13)), length(cont)=0)\nCalling runhandler(Writer, eff6) on it will find non matching effect and empty continuation. Hence it constructs a new Eff with original value and new continuation x -> eff_pure(Writer, x).\njulia> runhandler(Writer, eff6)\nEff(effectful=NoEffect{Writer{typeof(TypeClasses.neutral), NTuple{4, Int64}}}(Writer{typeof(TypeClasses.neutral), NTuple{4, Int64}}(TypeClasses.neutral, (2, 4, 7, 13))), length(cont)=0)\nFor performance reasons the Eff constructor will directly execute any computation which is run on an NoEffect effect. This explains the new effectful and length(cont)=0. You also see that mapping over NoEffect will actually get the wrapped value (here a Tuple) as the input, which is then wrapped into Writer.\neff_flatmap will then merge the accumulators, namely the \"world.\" from the plain Writer as well as the pure accumulator TypeClasses.neutral introduced by eff_pure. The merging is again realized by mapping over the Eff, and as we reached NoEffect effect, all computations are now directly executed.\nat last the old eff_flatmap operation gets active, which now merges the accumulators of the inner Writer \"world.\" and the outer accumulator \"hello.\". The merging is again realized by mapping over the Eff, and as the effect is already NoEffect, the computation is executed immediately, giving us\njulia> eff3.cont(7)\nEff(effectful=NoEffect{Writer{String, NTuple{4, Int64}}}(Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13))), length(cont)=0)\nrunhandler(Vector, eff3.cont(7)) finds now an Eff with empty continuation and different type Writer, hence a new Eff is build with eff_pure\nEff(eff3.effectful, Continuation(x -> _eff_pure(Vector, x)))\nFor performance improvements, the computation on NoEffect is again directly executed, leading into a new NoEffect of Vector of Writer.\njulia> runhandler(Vector, eff3.cont(7))\nEff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13))]), length(cont)=0)\nThe same happens for value 8, returning another Eff of NoEffect of Vector of Writer\nUsing the monad power of Eff, both results are now combined by flattening them\njulia> @syntax_flatmap begin\n        a = interpreted_continuation_Vector2(7)\n        b = interpreted_continuation_Vector2(8)\n        @pure [a...; b...]\n      end\nEff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13)), Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 8, 14))]), length(cont)=0)\nThe concrete implementation of Vector's eff_flatmap is slightly more general, but the principle is the same.\nthe continuation for the outer Vector (interpreted_continuation_Vector1) is now executed for the second value 3, too,  giving another NoEffect plain value.\nanalogously to how the inner two computations have been merged, also the outer two Eff of NoEffect of Vector get merged. We almost have our end result.\njulia> runhandler(Vector, runhandler(Writer, eff))\nEff(effectful=NoEffect{Vector{Writer{String, NTuple{4, Int64}}}}(Writer{String, NTuple{4, Int64}}[Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13)), Writer{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 8, 14)), Writer{String, NTuple{4, Int64}}(\"hello.world.\", (3, 9, 7, 19)), Writer{String, NTuple{4, Int64}}(\"hello.world.\", (3, 9, 8, 20))]), length(cont)=0)\nFinally runlast_ifpossible tries to extract the value out of the Eff-NoEffect combination.\njulia> runlast_ifpossible(runhandler(Vector, runhandler(Writer, eff)))\n4-element Vector{Writer{String, NTuple{4, Int64}}}:\nWriter{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 7, 13))\nWriter{String, NTuple{4, Int64}}(\"hello.world.\", (2, 4, 8, 14))\nWriter{String, NTuple{4, Int64}}(\"hello.world.\", (3, 9, 7, 19))\nWriter{String, NTuple{4, Int64}}(\"hello.world.\", (3, 9, 8, 20))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We have seen the concrete execution of one example, including how the effect system separates lazy computation from actual computation. As long as we haven't reached NoEffect and still have unkown handlers to handle, all computation is just lazily stored as functions for later execution. As soon as all handlers are handled, the result is wrapped into the special NoEffect effect, on which computation is now executed immediately. From the perspective of the user, the precise timing when something is executed is just an implementation. Hence also NoEffect is an implementation detail and you never need to worry about it. Still I hope this helped the interested reader to understand in more detail what is going on behind the scenes.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"That is it, I hope it is a little bit less magical now, however I myself have to commit that even after implementing the whole package, the power of the extensible effects concept keeps blowing my mind and stays magic.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ExtensibleEffects","category":"page"},{"location":"#ExtensibleEffects","page":"Home","title":"ExtensibleEffects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ExtensibleEffects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides an implementation of Extensible Effects. We follow the approach presented in the paper Freer Monads, More Extensible Effects which already has an Haskell implementation as well as a Scala implementation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Julia implementation is massively simplified, and hence can also serve as a good introduction to get to know the details behind Extensible Effects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Many effects are provided, ranging from Option, which can be handled very simple, to the very limit of what can be supported by ExtensibleEffects - the State effect. Still, all the implementations are short and easy to follow, so look into the instances.jl file to see how to write your own Effect handlings.","category":"page"},{"location":"#Presentation-at-JuliaCon-2021","page":"Home","title":"Presentation at JuliaCon 2021","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package was presented at JuliaCon 2021.","category":"page"},{"location":"","page":"Home","title":"Home","text":"find the video at youtube\nfind the presentation in this binder. The binder link provides you with a Jupyter environment where you can actually run julia code and explore the ExtensibleEffects further. The link will autostart into the presentation itself, clicking the big X on the top left will exit the presentation mode and bring you to a standard Jupyter notebook.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
